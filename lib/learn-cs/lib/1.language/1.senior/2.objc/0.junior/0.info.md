---
title: 简介
slug: /languages/objc/info
---

# 强大
unix系统大部分使用，很多语言的编译器或者解释器。
可移植
# 标准
C语言没有官方标准，但是有事实标准。
# 语法
;不能被省略 否则多行会被视为一行
# 编译语言
C语言需要编译后才能执行。
编译器先翻译代码形成中间代码，链接器会将中间代码和其他使用到的例如printf函数的代码结合起来生成可执行文件。
我们可以分别编译每个c模块，然后使用链接将多个模块链接成一个可执行程序。

中间代码(.o文件)：
中间代码无法直接执行，因为缺少启动代码（操作系统确定，不同的操作系统需要不同的启动代码。）
还缺少引入函数的代码，也叫做库代码，例如print函数的源代码在中间代码中还不存在。

# 面向过程
机构化编程

# 计算机工作原理
cpu负责计算
主要工作就是不断地从ram中读取指令并执行，一条一条的执行。主频就代表一秒能执行多少条指令。
cpu中也有工作区，也就是寄存器，寄存器保存数或者下一条指令的地址。
cpu只能理解有限的指令集，就像字符集一样。

ram内存负责在工作时保存程序和文件
rom负责永久保存数据
io设备负责人机交互

# include stdio.h
预处理指令，在编译前进行。前面加上#号就是为了区分是不是c语言代码。
告诉编译器，包含stdio.h中全部信息。
h文件一般定义常量或者进行函数声明，但是函数实现由链接器去找。

# 函数
int main(void)
返回一个int，这个int返回给操作系统。

# 声明
int num;
声明一般在作用域的顶部，而不是在文件顶部。编译器通过声明信息，为变量分配内存。现在也可以在所有位置。
所有变量在使用之前必须先定义，因为在定义的时候进行内存分配。

函数声明也类似，不包含函数体，可以用于检验使用是否正确。

# 赋值
int num = 1;
会拆分为两句，一句声明，一句赋值。
声明分配内存，赋值进行内存操作。

# 函数
当调用到某个函数时，上下文会切换到这个函数，直到返回。

# 转义字符
\n之类的字符用来代替无法打出或者表达不清楚的字符。
\n 之类的转义字符也是一个整数 例如\n=10

# 占位符
赋值的时候会对类型做转换。
%d为占位符，占位符不会对类型自动转换，例如%d打印float会输出一个无意义的垃圾值而不是float的整数部分。因为float和int的存储方式完全不同。
%代表变量在此处输出，d代表输出一个十进制的整数。

# 程序
程序由一个一个的函数组成，main函数作为入口。

# 变量与常量
int x = 14
x为变量 14为常量
整数常量默认为int，除非超过int范围，则用unsigned int

# 浮点数
浮点数使用科学计数法，常量默认使用double存储。2.3f则指明使用float存储。
124.75665 = 1.2475665 * 10^2 或者 1.2475665e2
浮点数将整数部分和指数部分分开存储，因为小数是无限的，所以浮点数会存在精度问题，
例如 7.00 的浮点数表示再进行计算的结果可能是 6.99999999999*
浮点数通常会比整数运算更慢。

float由32位组成，8位代表指数，24位表示尾数。float通常能精确到至少6位
所以2.0e20 + 1 - 1在编译器不优化的情况下不会返回2.0e20，换成2.0e4则可以。
double由64位组成，具体怎么分配由系统决定。

# bit byte word
1byte = 8bit
但是word是自然存储单元，例如8位机器，word = 8bit 64位机器，word = 64bit。

# 数据类型
int类型一般为一个word大小。
short long unsigned 用于修饰 int ，short int简写为short。只能约束大小不能大于int（因为不同的机器位不同）
不同的基本数据类型，提供不同的用途。更精细控制内存。

可以使用后缀来指明数据类型。
例如 1000l 编译器会使用long来存储这个1000

%luo 表示八进制打印long unsigned （计算数字是有符号整数，也会被当作无符号打印，高位省略）

char x = 'A'
char 类型事实上就是整数类型，但是其只占用一个byte。
此处，'A'被视为一个int整数，占用一个word，编译器默认按ASCII对应，将其转换成编码值，并传递给char类型。
由于字符实际上是整数，所以也可以写成
char x = '\101' 注意\[0]表示的是八进制，这里是八进制的65。也可以用16进制'\x41'代表'A'

# 自动类型转换
short 传递给 int会自动转换为更大的。

# 进制
c语言中 通过数字前加前缀表示不同的进制的数字。
0x
0表示八进制

# 数溢出
例如short一直++溢出，会从起点重新开始，因为高位会被省略。

# 字符串
“”代表包含了一个字符串，只是一种告诉编译器。
c语言使用字符数组存储字符串。
使用'\0'我也就是ASCII值为0的字符标识字符串的结束。所以数组所占用空间比字符数多1.
'x' "x" 后者由两个字符组成多一个'\0'

# sizeof
sizeof(char) 获得char类型占用的内存大小。
char name[20];
sizeof name 获取字符数组占用内存大小。此处()可有可无，建议加上。
sizeof返回占用内存字节数 strlen返回字符数，并计算到'\0'停止。

# 预处理
#开头的是预处理，用来提示编译器在编译程序之前处理。
#define 用于定义常量，系统也提供了很多常量。

# 表达式与语句
表达式由运算符和操作组合构成，操作组合除了操作数还有子表达式。
每个表达式都必须有一个返回值。

语句是一条完整的计算机指令。语句使用封号结尾。
legs = 4是表达式，加上；为语句。

# 作用域
{}代码块作用域
文件作用域（这个作用域的变量也叫全局变量）。类似于ts中的模块顶级作用域，

# 链接->可访问程度
c变量存在三种链接，外部，内部，空
代码块内变量为空链接。
文件作用域变量如果为外部链接，则可在多个文件中共享，其他文件内使用extern声明就可以使用，如果为内部则只能文件内共享。（默认为外部，使用static定义为内部）

# 存储->存储区域与生命周期
c变量存在两种存储时期，静态和自动存储时期

静态存储会在程序执行的过程中一直存在。文件作用域变量都是静态存储，即便是内部链接也是。

代码块变量为自动存储，进入代码块进行内存分配，退出代码块内存释放。

# 自动变量
自动存储时期，代码块作用域和空链接。就为自动变量。
函数内定义的所有变量都是自动变量。默认就是auto开头，可省略。

自动变量不会自动初始化，所以会出现野指针。
外部变量会自动初始化0 即便数组也是。但是外部变量初始化只能使用编译时常量。

# 静态变量
存储的位置不会发生改变的变量称为静态变量。

# register
寄存器变量，请求存储在寄存器中，不一定真的能存到。寄存器变量无法操作变量地址。

# 手动内存分配
int space[100000] 这样在栈区申请
malloc能按需申请堆内存，然后返回首地址。
变长数组 int arr[count], 也是自动变量，不需要手动回收。也是在运行时决定大小。

静态存储时期的变量在编译时就可以确定大小。
自动变量在运行时才能知道大小，随着函数调用产生和消失。使用堆栈管理最方便。
动态分配的内存在malloc相关产生，因为其不依赖任一个函数，所以容易产生碎片，速度较慢，使用堆管理。

# const
const float * pf 这里pf可变，pf指向的内存区域不能修改。
float * const pf 这里pf不可变，但是指向的内存区域能修改。

# 指针
变量的地址为指针，存储指针的变量为指针变量。

# struct
结构体是一种数据类型，在定义时不会占用内存，只有使用时才会占用内存。
在内存中是连续存储的。
嵌套结构体，先计算子结构体大小，记住结构体也只是普通的类型。
结构体变量使用.来引用。